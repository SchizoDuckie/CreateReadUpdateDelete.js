<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>CreateReadUpdateDelete.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" type="text/css">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/cayman.css">
    <link rel="stylesheet" href="css/prism.css">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">CreateReadUpdateDelete.js</h1>
      <h2 class="project-tagline"></h2>
    </section>
    <section data-spy="scroll" data-target=".scrollspy" class="main-content">
      <div class="row">
        <div class="col-md-3 col-xs-3 bs-docs-sidebar">
          <ul id="sidebar" class="nav nav-stacked fixed">
            <li class="active"><a href="index.html">Main
                <ul class="nav nav-stacked">
                </ul></a></li>
            <li><a href="CRUD.SqliteAdapter.js.html">CRUD.SqliteAdapter.js</a></li>
            <li><a href="CRUD.js.html">CRUD.js</a></li>
          </ul>
        </div>
        <div class="col-md-9">
          <section id="Main" class="readme"><h1>CreateReadUpdateDelete.js</h1>
<p>CreateReadUpdateDelete.js aims to bring you a tiny footprint, platform independent ORM/ActiveRecord implementation for Javascript that works flawlessly on SQLite / WebSQL databases,
or any flavor of remote database you can think of via serverside JSON API</p>
<p>Written in Plain Old JavaScript without any framework dependencies, you can use this with Mootools, Jquery, Zepto, Ember, or whatever your drug of choice is.</p>
<h1>ActiveRecord? Orm?</h1>
<p>ActiveRecord/ORM is a technique that fits perfectly into the DRY (Don't Repeat Yourself) paradigm.
It takes away all the hassle of creating Insert, Select, Update and Delete database queries. You create your class, set some properties, call Save, and a database record is created automagicaly.
If the object you're referring to already exists in the database, it will be updated.</p>
<p>Want to find related data? Instantiate an object, call Find() on it with the filters you need, and the onComplete callback returns you your data.</p>
<p>If you're doing data storage right, you don't have to write <em>any</em> SQL, at all.</p>
<h1>Example, connecting to sqlite</h1>
<p>First, define an adapter. In this case we use an SQLiteAdapter to the database 'myDbName '</p>
<pre><code class="language-javascript">window.dbAdapter = new CRUD.SQLiteAdapter('myDbName');
</code></pre>
<p>Then, define some entity objects using CRUD.define</p>
<pre><code class="language-javascript">var Presentation = CRUD.define({
		className: 'Presentation',
		table : 'presentations',
		primary : 'ID_Presentation',
		fields: ['ID_Presentation','ID_Client','name','template','forceUpdate', 'lastUpdated','lastAccessed','ID_Catalog', 'ID_Category'],
		relations: {
			'Slide': CRUD.RELATION_MANY
		},
		connectors: {
			'Slide' : 'Presentationslide' // connectors are the way for RELATION_MANY to see what the joining table is
		},
		adapter: 'dbAdapter'
	}, {

	display: function() {
		//console.log(&quot;Displaying presentation &quot;+this.get('name'));
		//console.log(this.databaseValues);
		var d = document.createElement('div');
		d.innerHTML = 'Presentation:'+ this.get('name');
		d.id = 'pres_'+this.getID();
		document.body.appendChild(d);
		// find slides for this presentation, it's a many:many relation.
		this.Find(Slide, {}, { onSuccess: function(slides) {
			for(var i = 0; i&lt; slides.length; i++) {
				slides[i].display(d.id);
			}
		}});
	}
});
</code></pre>
<p>These entity objects map directly to an Sqlite database table. In this case we're setting up a many:many relationship</p>
<pre><code class="language-javascript">var Slide = CRUD.define({
		className: 'Slide',
		table : 'slides',
		primary : 'ID_Slide',
		fields: ['ID_Slide','ID_User','Title','SubTitle','Content1','Content2', 'Content3','ID_Slidetemplate'],
		
		relations: {
			'Presentation': CRUD.RELATION_MANY,
			'Slidetemplate': CRUD.RELATION_FOREIGN
		},
		connectors: {
			'Presentation' : 'Presentationslide'
		},
		adapter: 'dbAdapter'
	}, {

	display : function(target) {
		var d = document.createElement('div');
		d.innerHTML = this.get('ID_Slide') + ' - '+ this.get('Title')  + ' - '+ this.get('SubTitle');

		target = target ? document.getElementById(target) : document.body;
		target.appendChild(d);
	}

});
</code></pre>
<p>The connecting table is also defined as an entity, but this has 2 foreign relations.</p>
<pre><code class="language-javascript">var Presentationslide = CRUD.define({
		className: 'Presentationslide',
		table : 'presentations_slides',
		primary : 'ID_PresentationSlide',
		fields: ['ID_PresentationSlide', 'ID_Presentation', 'ID_Slide', 'slideIndex', 'subSlideIndex'],
		relations: {
			'Presentation': CRUD.RELATION_FOREIGN,
			'Slide': CRUD.RELATION_FOREIGN
		},
		defaultValues: {
			slideIndex: 0,
			subSlideIndex: 0
		},
		adapter: 'dbAdapter'
	}, {
	display: function() {
		return new Element(&quot;div&quot;, {html: &quot;Presentationslide: &quot;+this.get('Name') });
	}
});
</code></pre>
<p>We initialize the whole stuff on onload or domready like this:</p>
<pre><code class="language-javascript">window.onload = function() {
	window.dbAdapter = new CRUD.SQLiteAdapter('myDbName');
	// This will return an array with Presentation objects on success.
	CRUD.Find(Presentation, {} , { onSuccess: function(result) {
			for (var i=0; i&lt; result.length; i++) {
				result[i].display();
			}
		}
	});

}
</code></pre>
<p>To create a new Presentation, this is enough:</p>
<pre><code class="language-javascript">var pres = new Presentation();
pres.set('name', 'test');
pres.Save();
</code></pre>
<p>A more advanced example: Create a Presentation and a Slide, and use Connect to automagically create the relation between them, in this many:many case a Presentationslide object.</p>
<pre><code class="language-javascript">var pres = new Presentation();
pres.set({
	name: 'test presentation',
	template: 'ImageOnly'
})

var slide = new Slide();
slide.set({
	Content1: '&lt;h1&gt;Test!&lt;/h1&gt;',
	Title : 'Test Slide',
	SubTitle: 'Test SubTitle'
});

pres.Connect(slide, { onComplete: function(r) {
          console.log(&quot;CREATED connection between presentation &quot;+pres.getID()+&quot; and slide &quot;+slide.getID());
      }
});
</code></pre>
</section>
          <div class="footer site-footer">
            <div class="span site-footer-owner"><a href="https://github.com/mr-doc/mr-doc-theme-cayman">Cayman</a> is maintained by <a href="https://github.com/iwatakeshi">iwatakeshi</a>.</div>
            <div class="span site-footer-credits">This page was generated by <a href="https://github.com/mr-doc/mr-doc">Mr. Doc</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</div>
          </div>
        </div>
      </div>
    </section>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/affix.js"></script>
    <script src="js/dropdown.js"></script>
    <script src="js/scrollspy.js"></script>
    <script src="js/prism.js"></script>
    <script src="js/prism-bash.js"></script>
    <script>
      $(document).ready(function(){
        $('body').scrollspy({
          target: ".bs-docs-sidebar",
          offset: 40
        });
        $('#sidebar').affix({
          offset:{
            bottom:60,
            top: 60
          }
        }) 
      });
    </script>
  </body>
</html>
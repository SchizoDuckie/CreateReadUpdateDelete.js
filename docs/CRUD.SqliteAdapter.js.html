<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>CreateReadUpdateDelete.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" type="text/css">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/cayman.css">
    <link rel="stylesheet" href="css/prism.css">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">CreateReadUpdateDelete.js</h1>
      <h2 class="project-tagline"></h2>
    </section>
    <section data-spy="scroll" data-target=".scrollspy" class="main-content">
      <div class="row">
        <div class="col-md-3 col-xs-3 bs-docs-sidebar">
          <ul id="sidebar" class="nav nav-stacked fixed">
            <li><a href="index.html">Main</a></li>
            <li class="active"><a href="CRUD.SqliteAdapter.js.html">CRUD.SqliteAdapter.js
                <ul class="nav nav-stacked">
                  <li><a href="#SQLiteAdapter"><i class="alert alert-info"></i><span>SQLiteAdapter</span></a>
                  </li>
                  <li><a href="#Init"><i class="alert alert-info"></i><span>Init</span></a>
                  </li>
                  <li><a href="#updateQuerySuccess"><i class="alert alert-info"></i><span>updateQuerySuccess</span></a>
                  </li>
                  <li><a href="#updateQueryError"><i class="alert alert-info"></i><span>updateQueryError</span></a>
                  </li>
                  <li><a href="#insertQuerySuccess"><i class="alert alert-info"></i><span>insertQuerySuccess</span></a>
                  </li>
                  <li><a href="#insertQueryError"><i class="alert alert-info"></i><span>insertQueryError</span></a>
                  </li>
                  <li><a href="#verifyTables"><i class="alert alert-info"></i><span>verifyTables</span></a>
                  </li>
                  <li><a href="#parseSchemaInfo"><i class="alert alert-info"></i><span>parseSchemaInfo</span></a>
                  </li>
                  <li><a href="#createTables"><i class="alert alert-info"></i><span>createTables</span></a>
                  </li>
                  <li><a href="#createFixtures"><i class="alert alert-info"></i><span>createFixtures</span></a>
                  </li>
                  <li><a href="#delayUntilSetupDone"><i class="alert alert-info"></i><span>delayUntilSetupDone</span></a>
                  </li>
                  <li><a href="#Find"><i class="alert alert-info"></i><span>Find</span></a>
                  </li>
                  <li><a href="#FindCount"><i class="alert alert-info"></i><span>FindCount</span></a>
                  </li>
                  <li><a href="#Persist"><i class="alert alert-info"></i><span>Persist</span></a>
                  </li>
                  <li><a href="#Delete"><i class="alert alert-info"></i><span>Delete</span></a>
                  </li>
                  <li><a href="#executeQuery"><i class="alert alert-info"></i><span>executeQuery</span></a>
                  </li>
                  <li><a href="#Database"><i class="alert alert-info"></i><span>Database</span></a>
                  </li>
                  <li><a href="#execute"><i class="alert alert-info"></i><span>execute</span></a>
                  </li>
                  <li><a href="#SQLBuilder"><i class="alert alert-info"></i><span>SQLBuilder</span></a>
                  </li>
                </ul></a></li>
            <li><a href="CRUD.js.html">CRUD.js</a></li>
          </ul>
        </div>
        <div class="col-md-9">
          <section id="SQLiteAdapter">
            <h1>SQLiteAdapter</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>CRUD.SQLiteAdapter()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><h2>CRUD.SQliteAdapter</h2>
<p>WebSQL adapter for CreateReadUpdateDelete.js<br />(Currently the only one available)</p><p>This is called from CRUD.setAdapter()</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>database</td>
                <td>string</td>
                <td><p>Database Name</p></td>
              </tr>
              <tr>
                <td>dbOptions</td>
                <td>object</td>
                <td><p>options to pass to window.openDatabase.</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">CRUD.SQLiteAdapter = function(database, dbOptions) {
    this.databaseName = database;
    this.dbOptions = dbOptions;
    this.lastQuery = false;
    this.initializing = true;
    CRUD.ConnectionAdapter.apply(this, arguments);
    var db;
    var self = this;</code></pre>
          <section id="Init">
            <h1>Init</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>this.Init()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Create a new CRUD.Database instance that opens the database, make sure all tables and indexes exist and create them if they don&#39;t</p></div>
          <pre><code class="language-javascript">this.Init = function() {
    this.db = db = new CRUD.Database(self.databaseName);
    return db.connect().then(function() {
        CRUD.log(&quot;SQLITE connection created to &quot;, self.databaseName);
        return verifyTables().then(function() {
            self.initializing = false;
        });
    });
};</code></pre>
          <section id="updateQuerySuccess">
            <h1>updateQuerySuccess</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>updateQuerySuccess()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Generic update query callback that logs writesExecuted and sets update action.</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>resultSet</td>
                <td>resultSet</td>
                <td><p>resulting from an update query.</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td>resultSet</td>
                <td><p>enriched resultSet with Action executed.</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">function updateQuerySuccess(resultSet) {
    CRUD.stats.writesExecuted++;
    resultSet.Action = 'updated';
    return resultSet;
}</code></pre>
          <section id="updateQueryError">
            <h1>updateQueryError</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>updateQueryError()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Generic update query error callback that logs writesExecuted and the error.</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>err</td>
                <td>Error</td>
                <td><p>WebSQL error</p></td>
              </tr>
              <tr>
                <td>tx</td>
                <td>Transaction</td>
                <td><p>WebSQL Transaction</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td></td>
                <td></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">function updateQueryError(err, tx) {
    console.error(&quot;Update query error!&quot;, err);
    CRUD.stats.writesExecuted++;
    return;
}</code></pre>
          <section id="insertQuerySuccess">
            <h1>insertQuerySuccess</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>insertQuerySuccess()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Generic insert query callback that logs writesExecuted and sets inserted action + id</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>resultSet</td>
                <td>resultSet</td>
                <td><p>resulting from an insert query.</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td>resultSet</td>
                <td><p>enriched resultSet with Action executed and ID property</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">function insertQuerySuccess(resultSet) {
    resultSet.Action = 'inserted';
    resultSet.ID = resultSet.rs.insertId;
    CRUD.stats.writesExecuted++;
    return resultSet;
}</code></pre>
          <section id="insertQueryError">
            <h1>insertQueryError</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>insertQueryError()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Generic insert query error callback that logs writesExecuted and the error.</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>err</td>
                <td>Error</td>
                <td><p>WebSQL error</p></td>
              </tr>
              <tr>
                <td>tx</td>
                <td>Transaction</td>
                <td><p>WebSQL Transaction</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td>error</td>
                <td></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">function insertQueryError(err, tx) {
    CRUD.stats.writesExecuted++;
    console.error(&quot;Insert query error: &quot;, err);
    return err;
}</code></pre>
          <section id="verifyTables">
            <h1>verifyTables</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>verifyTables()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Verify that all tables for registered entities exist.<br />This starts a promise chain that executes the following steps:</p><ul>
<li>Fetch a list of all tables and indexes</li>
<li>Iterate all known entities and:</li>
<li>Execute their createStatements if they haven&#39;t been created.</li>
<li>Execute any migrations in sequence if the localStorage value database.version.<table> is smaller than the highest migration number</li>
<li>Compare the list of indexes and create the ones that don&#39;t exist</li>
<li>Insert fixtures if the table has been freshly created</li>
</ul>
</div>
          <pre><code class="language-javascript">function verifyTables() {
    CRUD.log('verifying that tables exist');
    var tables = [],
        indexes = {};</code></pre>
          <section id="parseSchemaInfo">
            <h1>parseSchemaInfo</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>parseSchemaInfo()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Pre-Parse database schema info for further processing. Finds tables and indexes.</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>database</td>
                <td>resultSet</td>
                <td><p>description</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td></td>
                <td><p>void</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">function parseSchemaInfo(resultset) {
    for (var i = 0; i &lt; resultset.rs.rows.length; i++) {
        var row = resultset.rs.rows.item(i);
        if (row.name.indexOf('sqlite_autoindex') &gt; -1 || row.name == '__WebKitDatabaseInfoTable__') continue;
        if (row.type == 'table') {
            tables.push(row.tbl_name);
        } else if (row.type == 'index') {
            if (!(row.tbl_name in indexes)) {
                indexes[row.tbl_name] = [];
            }
            indexes[row.tbl_name].push(row.name);
        }
    }
    return;
}</code></pre>
          <section id="createTables">
            <h1>createTables</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>createTables()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Iterate the list of registered entities and creates their tables if they don&#39;t exist.<br />Run the migrations when needed if the table version is out of sync</p></div>
          <pre><code class="language-javascript">function createTables() {
    return Promise.all(Object.keys(CRUD.EntityManager.entities).map(function(entityName) {
        var entity = CRUD.EntityManager.entities[entityName];
        if (tables.indexOf(entity.table) == -1) {
            if (!entity.createStatement) {
                throw &quot;No create statement found for &quot; + entity.getType() + &quot;. Don't know how to create table.&quot;;
            }
            return db.execute(entity.createStatement).then(function() {
                tables.push(entity.table);
                localStorage.setItem('database.version.' + entity.table, ('migrations' in entity) ? Math.max.apply(Math, Object.keys(entity.migrations)) : 1);
                CRUD.log(entity.getType() + &quot; table created.&quot;);
                return entity;
            }, function(err) {
                CRUD.log(&quot;Error creating &quot; + entity.getType(), err);
                throw &quot;Error creating table: &quot; + entity.table + &quot; for &quot; + entity.getType();
            }).then(createFixtures).then(function() {
                CRUD.log(&quot;Table created and fixtures inserted for &quot;, entity.getType());
                return;
            });
        }
        return;
    }));
}

/**
 * Run migrations for a table if the version stored in localStorage is out of sync.
 * All tables created by CreateReadUpdateDelete.js are versioned this way.
 * For more info on migrations see the docs.
 * @return {void} void
 */
function runMigrations() {
    return Promise.all(Object.keys(CRUD.EntityManager.entities).map(function(entityName) {
        var entity = CRUD.EntityManager.entities[entityName];
        if (entity.migrations) {
            var currentVersion = !localStorage.getItem('database.version.' + entity.table) ? 1 : parseInt(localStorage.getItem('database.version.' + entity.table), 10);
            if (isNaN(currentVersion)) {
                currentVersion = 1;
            }
            var highestVersion = Math.max.apply(Math, Object.keys(entity.migrations));
            if (currentVersion == highestVersion) return;
            return Promise.all(Object.keys(entity.migrations).map(function(version) {
                if (parseInt(version) &gt; currentVersion) {
                    return Promise.all(entity.migrations[version].map(function(migration) {
                        CRUD.log('Executing migration: ', migration);
                        return db.execute(migration).then(function(result) {
                            CRUD.log(&quot;Migration success!&quot;, result);
                            return true;
                        }, function(err) {
                            throw &quot;Migration &quot; + version + &quot; failed for entity &quot; + entityName;
                        });
                    })).then(function() {
                        CRUD.log(&quot;All migrations executed for version &quot;, version);
                        localStorage.setItem('database.version.' + entity.table, version);
                        return true;
                    });
                }
                return true;
            }));
        }
    }));
}

/**
 * Iterate the list of existing and non-existing indexes for each entity and create the ones that don't exist.
 * @return {void} void
 */
function createIndexes() {
    // create listed indexes if they don't already exist.
    return Promise.all(Object.keys(CRUD.EntityManager.entities).map(function(entityName) {
        var entity = CRUD.EntityManager.entities[entityName];
        if (('indexes' in entity)) {
            return Promise.all(entity.indexes.map(function(index) {
                var indexName = index.replace(/\W/g, '') + '_idx';
                if (!(entity.table in indexes) || indexes[entity.table].indexOf(indexName) == -1) {
                    return db.execute(&quot;create index if not exists &quot; + indexName + &quot; on &quot; + entity.table + &quot; (&quot; + index + &quot;)&quot;).then(function(result) {
                        CRUD.log(&quot;index created: &quot;, entity.table, index, indexName);
                        if (!(entity.table in indexes)) {
                            indexes[entity.table] = [];
                        }
                        indexes[entity.table].push(indexName);
                        return;
                    });
                }
                return;
            }));
        }
    }));
}

// fetch schema info and perform setup sequence.
return db.execute(&quot;select type,name,tbl_name from sqlite_master&quot;)
    .then(parseSchemaInfo)
    .then(createTables)
    .then(runMigrations)
    .then(createIndexes).then(function(result) {
        CRUD.log(&quot;All migrations are done!&quot;);
        self.initializing = false;
    });
    }</code></pre>
          <section id="createFixtures">
            <h1>createFixtures</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>createFixtures()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Insert fixtures for an entity if they exist</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>entity</td>
                <td>CRUD.Entity</td>
                <td><p>entity to insert fixtures for</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td>Promise</td>
                <td><p>that resolves when all fixtures were inserted or immediately when none are defined</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">function createFixtures(entity) {
    return new Promise(function(resolve, reject) {
        if (!entity.fixtures) return resolve();
        return Promise.all(entity.fixtures.map(function(fixture) {
            CRUD.fromCache(entity.getType(), fixture).Persist(true);
        })).then(resolve, reject);
    });
}</code></pre>
          <section id="delayUntilSetupDone">
            <h1>delayUntilSetupDone</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">function</div><span>&nbsp;</span><span>delayUntilSetupDone()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Non-blocking delay function that waits for execution until all initialization is done<br />This places all calls to CRUD.Find in a setTimeout loop until the tables are created and fixtures are inserted.<br />When setup is done, the callback is executed immediately.</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>to</td>
                <td>callback</td>
                <td><p>run when setup is done</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td></td>
                <td></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">function delayUntilSetupDone(func) {
    if (!self.initializing) {
        return func();
    } else {
        setTimeout(delayUntilSetupDone, 50, func);
    }
}</code></pre>
          <section id="Find">
            <h1>Find</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>this.Find()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>what</td>
                <td>CRUD.Entity</td>
                <td><p>type of CRUD.Entity to query the database for</p></td>
              </tr>
              <tr>
                <td>filters</td>
                <td>object</td>
                <td><p>Properties to create a WHERE statement from</p></td>
              </tr>
              <tr>
                <td>options</td>
                <td>object</td>
                <td><p>Optional array of options: { orderBy, groupBy, limit, justthese }</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">this.Find = function(what, filters, options) {
    var builder = new CRUD.Database.SQLBuilder(what, filters, options);
    var query = builder.buildQuery();

    CRUD.log(&quot;Executing query via sqliteadapter: &quot;, options, query);
    return new Promise(function(resolve, fail) {
        return delayUntilSetupDone(function() {
            db.execute(query.query, query.parameters).then(function(resultset) {
                    var output = [];
                    for (var i = 0; i &lt; resultset.rs.rows.length; i++) {
                        output.push(resultset.rs.rows.item(i));
                    }
                    resolve(output);
                },
                function(resultSet, sqlError) {
                    CRUD.log('SQL Error in FIND : ', sqlError, resultSet, query);
                    fail();
                });
        });
    });
};</code></pre>
          <section id="FindCount">
            <h1>FindCount</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>this.FindCount()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>what</td>
                <td>CRUD.Entity</td>
                <td><p>type of CRUD.Entity to query the database for</p></td>
              </tr>
              <tr>
                <td>filters</td>
                <td>object</td>
                <td><p>Properties to create a WHERE statement from</p></td>
              </tr>
              <tr>
                <td>options</td>
                <td>object</td>
                <td><p>Optional array of options: { orderBy, groupBy, limit, justthese }</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">this.FindCount = function(what, filters, options) {
    var builder = new CRUD.Database.SQLBuilder(what, filters, options);
    var query = builder.buildCountQuery();

    CRUD.log(&quot;Executing query via sqliteadapter: &quot;, options, query);
    return new Promise(function(resolve, fail) {
        return delayUntilSetupDone(function() {
            db.execute(query.query, query.parameters).then(function(resultset) {
                    var row = resultset.rs.rows.item(0);
                    resolve(row[Object.keys(row)[0]]);
                },
                function(resultSet, sqlError) {
                    CRUD.log('SQL Error in FIND : ', sqlError, resultSet, query);
                    fail();
                });
        });
    });
};</code></pre>
          <section id="Persist">
            <h1>Persist</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>this.Persist()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Save a changed or new entity into the database.</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>what</td>
                <td>CRUD.Entity</td>
                <td><p>an instance of a CRUD.Entity</p></td>
              </tr>
              <tr>
                <td>forceInsert</td>
                <td>boolean</td>
                <td><p>(Optional) Flag all values dirty and append them to the query</p></td>
              </tr>
              <tr>
                <td>mode</td>
                <td>string</td>
                <td><p>(Optional) insert mode to use with forceInsert: Default: INSERT. Can also be REPLACE</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">this.Persist = function(what, forceInsert, mode) {
    CRUD.stats.writesQueued++;
    mode = mode || 'INSERT';
    var query = [],
        values = [],
        valmap = [],
        names = [];

    function mapValues(field) {
        names.push(field);
        values.push('?');
        valmap.push(what.__dirtyValues__[field]);
    }

    function mapChangedValues(field) {
        if (!(field in what.__dirtyValues__) &amp;&amp; !(field in what.__values__)) {
            names.push(field);
            values.push('?');
            valmap.push(CRUD.EntityManager.entities[what.getType()].defaultValues[field]);
        }
    }

    function mapAutoSerialize(field) {
        if (names.indexOf(field) &gt; -1) {
            valmap[names.indexOf(field)] = JSON.stringify(valmap[names.indexOf(field)]);
        }
    }

    // iterate all fields changed 
    Object.keys(what.__dirtyValues__).map(mapValues);
    // add defaults
    Object.keys(CRUD.EntityManager.entities[what.getType()].defaultValues).map(mapChangedValues);

    // json_encode any fields that are defined as needing serializing
    CRUD.EntityManager.entities[what.getType()].autoSerialize.map(mapAutoSerialize);

    if (what.getID() === false || undefined === what.getID() || forceInsert) { // new object : insert.
        // insert
        query.push(mode + ' INTO ', CRUD.EntityManager.entities[what.getType()].table, '(', names.join(&quot;,&quot;), ') VALUES (', values.join(&quot;,&quot;), ');');
        CRUD.log(query.join(' '), valmap);
        return db.execute(query.join(' '), valmap).then(insertQuerySuccess, insertQueryError);
    } else { // existing : build an update query.
        query.push('UPDATE', CRUD.EntityManager.entities[what.getType()].table, 'SET', names.map(function(name) {
            return name + ' = ?';
        }).join(','));
        valmap.push(what.getID());
        query.push('WHERE', CRUD.EntityManager.getPrimary(what.getType()), '= ?');

        return db.execute(query.join(' '), valmap).then(updateQuerySuccess, updateQueryError);
    }
};</code></pre>
          <section id="Delete">
            <h1>Delete</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>this.Delete()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>what</td>
                <td>CRUD.Entity</td>
                <td><p>Entity instance to delete</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td>Promise</td>
                <td><p>Promise that resolves when done</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">this.Delete = function(what) {
    if (what.getID() !== false) {
        query = ['delete from', CRUD.EntityManager.entities[what.getType()].table, 'where', CRUD.EntityManager.getPrimary(what.getType()), '= ?'].join(' ');
        return db.execute(query, [what.getID()]).then(function(resultSet) {
            resultSet.Action = 'deleted';
            return resultSet;
        }, function(e) {
            CRUD.log(&quot;error deleting element from db: &quot;, e);
            throw e;
        });
    } else {
        return false;
    }
};

return this;
};</code></pre>
          <section id="executeQuery">
            <h1>executeQuery</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>CRUD.executeQuery()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>A Handy Shorthand function to execute a raw SQL query and return the result with a promise.</p></div>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>query</td>
                <td>string</td>
                <td><p>Query to execute. Optionally use bound parameters with ? as a placeholder.</p></td>
              </tr>
              <tr>
                <td>bindings</td>
                <td>array</td>
                <td><p>Optional array with query for the query</p></td>
              </tr>
              <tr>
                <td>return</td>
                <td>Promise</td>
                <td><p>promise that resolves when query was executed</p></td>
              </tr>
            </tbody>
          </table>
          <pre><code class="language-javascript">CRUD.executeQuery = function(query, bindings) {
    return CRUD.EntityManager.getAdapter().db.execute(query, bindings || []);
};</code></pre>
          <section id="Database">
            <h1>Database</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>CRUD.Database()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><hr>
<p>CRUD.Database.js, a simple database abstraction layer.<br />Adapted from mootools Database.js by  Dipl.-Ing. (FH) AndrÃ© Fiedler <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x6b;&#x6f;&#x6e;&#x74;&#x61;&#x6b;&#x74;&#x40;&#118;&#x69;&#x73;&#x75;&#97;&#108;&#100;&#x72;&#x75;&#x67;&#115;&#x2e;&#x6e;&#101;&#x74;">&#x6b;&#x6f;&#x6e;&#x74;&#x61;&#x6b;&#x74;&#x40;&#118;&#x69;&#x73;&#x75;&#97;&#108;&#100;&#x72;&#x75;&#x67;&#115;&#x2e;&#x6e;&#101;&#x74;</a><br />Removed all moo dependencies and converted to POJS<br />December 2013: Updated for use of promises.<br />...</p></div>
          <pre><code class="language-javascript">CRUD.Database = function(name, options) {
    options = options || {
        version: '1.0',
        estimatedSize: 655360
    };

    var lastInsertRowId = 0;
    var db = false;
    var dbName = name || false;

    this.lastInsertId = function() {
        return lastInsertRowId;
    };

    this.close = function() {
        return db.close();
    };

    this.getDB = function() {
        return db;
    };

    var queryQueue = [];</code></pre>
          <section id="execute">
            <h1>execute</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>this.execute()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>Execute a db query and promise a resultset.<br />Queries are queue up based upon if they are insert or select queries.<br />selects get highest priority to not lock the UI when batch inserts or updates<br />are happening.</p></div>
          <pre><code class="language-javascript">this.execute = function(sql, valueBindings) {
    if (!db) return;
    return new Promise(function(resolve, fail) {
        queryQueue[sql.indexOf('SELECT') === 0 ? 'unshift' : 'push']({
            sql: sql,
            valueBindings: valueBindings,
            resolve: resolve,
            fail: fail
        });
        setTimeout(processQueue, 10);
    });
};

function processQueue() {
    if (queryQueue.length &gt; 0) {
        db.transaction(function(transaction) {
            var localQueue = queryQueue.splice(0, 25);
            if (localQueue.length === 0) return;
            localQueue.map(function(query) {

                function sqlOK(transaction, rs) {
                    query.resolve(new CRUD.Database.ResultSet(rs));
                }

                function sqlFail(transaction, error) {
                    CRUD.log(&quot;SQL FAIL!!&quot;, error, transaction);
                    query.fail(error, transaction);
                }
                transaction.executeSql(query.sql, query.valueBindings, sqlOK, sqlFail);
                if (CRUD.DEBUG) {
                    CRUD.log(query.sql, query.valueBindings);
                }
            });
        });
    }
}

this.connect = function() {
    return new Promise(function(resolve, fail) {
        try {
            db = openDatabase(dbName, options.version, '', options.estimatedSize);
            if (!db) {
                fail(&quot;could not open database &quot; + dbName);
            } else {
                CRUD.log(&quot;DB connection to &quot;, dbName, &quot; opened!&quot;);
                resolve(this);
            }
        } catch (E) {
            CRUD.log(&quot;DB ERROR &quot; + E.toString());
            fail('ERROR!' + E.toString(), E);
        }
    });
};
};

CRUD.Database.ResultSet = function(rs) {
this.rs = rs;
this.index = 0;
return this;
};

CRUD.Database.ResultSet.prototype.next = function() {
var row = null;
if (this.index &lt; this.rs.rows.length) {
    row = new CRUD.Database.ResultSet.Row(this.rs.rows.item(this.index++));
}
return row;
};

CRUD.Database.ResultSet.Row = function(row) {
this.row = row;
return this;
};

CRUD.Database.ResultSet.Row.prototype.get = function(index, defaultValue) {
var col = this.row[index];
return (col) ? col : defaultValue;
};</code></pre>
          <section id="SQLBuilder">
            <h1>SQLBuilder</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>&nbsp;</span><span>CRUD.Database.SQLBuilder()</span><span>&nbsp;</span>
            </p>
          </section>
          <div class="description"><p>My own query builder, ported from PHP to JS.<br />Should still be refactored and prettified, but works pretty nice so far.</p></div>
          <pre><code class="language-javascript">CRUD.Database.SQLBuilder = function(entity, filters, options) {
    this.entity = entity instanceof CRUD.Entity ? entity.getType() : entity;
    this.entityConfig = CRUD.EntityManager.entities[this.entity];
    this.filters = filters || {};
    this.options = options || {};
    this.justthese = [];
    this.wheres = [];
    this.joins = [];
    this.fields = [];
    this.orders = [];
    this.groups = [];
    this.parameters = []; // parameters to bind to sql query.

    Object.keys(this.filters).map(function(key) {
        this.buildFilters(key, this.filters[key], this.entity);
    }, this);

    if (this.options.orderBy) {
        this.orders.push(this.prefixFieldNames(this.options.orderBy.replace('ORDER BY', '')));
    } else {
        if (this.entityConfig.orderProperty &amp;&amp; this.entityConfig.orderDirection &amp;&amp; this.orders.length === 0) {
            this.orders.push(this.getFieldName(this.entityConfig.orderProperty) + &quot; &quot; + this.entityConfig.orderDirection);
        }
    }

    if (this.options.groupBy) {
        this.groups.push(this.options.groupBy.replace('GROUP BY', ''));
    }

    this.limit = this.options.limit ? 'LIMIT ' + options.limit : 'LIMIT 0,1000';

    (this.options.justthese || CRUD.EntityManager.entities[this.entity].fields).map(function(field) {
        this.fields.push(this.getFieldName(field));
    }, this);
};


CRUD.Database.SQLBuilder.prototype = {

    getFieldName: function(field, table) {
        return (table || this.entityConfig.table) + '.' + field;
    },

    prefixFieldNames: function(text) {
        var fields = text.split(',');
        return fields.map(function(field) {
            var f = field.trim().split(' ');
            var direction = f[1].toUpperCase().match(/(ASC|DESC)/)[0];
            field = f[0];
            if (this.entityConfig.fields.indexOf(field) &gt; -1) {
                field = this.getFieldName(field);
            }
            return field + ' ' + direction;
        }, this).join(', ');
    },

    buildFilters: function(what, value, _class) {
        var relatedClass = CRUD.EntityManager.hasRelation(_class, what);
        if (relatedClass) {
            for (var val in value) {
                this.buildFilters(val, value[val], what);
                this.buildJoins(_class, what);
            }
        } else if (!isNaN(parseInt(what, 10))) { // it's a custom sql where clause, just field=&gt;value). unsafe because parameters are unbound, but very for custom queries.
            this.wheres.push(value);
        } else { // standard field=&gt;value whereclause. Prefix with tablename for easy joins and push a value to the .
            if (what == 'ID') what = CRUD.EntityManager.getPrimary(_class);
            this.wheres.push(this.getFieldName(what, CRUD.EntityManager.entities[_class].table) + ' = ?');
            this.parameters.push(value);
        }
    },

    buildJoins: function(theClass, parent) { // determine what joins to use
        if (!parent) return; // nothing to join on, skip.
        var entity = CRUD.EntityManager.entities[theClass];
        parent = CRUD.EntityManager.entities[parent];

        switch (parent.relations[entity.getType()]) { // then check the relationtype
            case CRUD.RELATION_SINGLE:
            case CRUD.RELATION_FOREIGN:
                if (entity.fields.indexOf(parent.primary) &gt; -1) {
                    this.addJoin(parent, entity, parent.primary);
                } else if (parent.fields.indexOf(entity.primary) &gt; -1) {
                    this.addJoin(parent, entity, entity.primary);
                }
                break;
            case CRUD.RELATION_MANY: // it's a many:many relation. Join the connector table and then the related one.
                connectorClass = parent.connectors[entity.getType()];
                conn = CRUD.EntityManager.entities[connectorClass];
                this.addJoin(conn, entity, entity.primary).addJoin(parent, conn, parent.primary);
                break;
            case CRUD.RELATION_CUSTOM:
                var rel = parent.relations[entity.getType()];
                this.joins = this.joins.unshift(['LEFT JOIN', entity.table, 'ON', this.getFieldName(rel.sourceProperty, parent.table), '=', this.getFieldName(rel.targetProperty, entity.table)].join(' '));
                break;
            default:
                throw new Exception(&quot;Warning! class &quot; + parent.getType() + &quot; probably has no relation defined for class &quot; + entity.getType() + &quot;  or you did something terribly wrong...&quot; + JSON.encode(parent.relations[_class]));
        }
    },

    addJoin: function(what, on, fromPrimary, toPrimary) {
        var join = ['LEFT JOIN', what.table, 'ON', this.getFieldName(fromPrimary, on.table), '=', this.getFieldName(toPrimary || fromPrimary, what.table)].join(' ');
        if (this.joins.indexOf(join) == -1) {
            this.joins.push(join);
        }
        return this;
    },

    buildQuery: function() {

        var where = this.wheres.length &gt; 0 ? ' WHERE ' + this.wheres.join(&quot; \n AND \n\t&quot;) : '';
        var order = (this.orders.length &gt; 0) ? ' ORDER BY ' + this.orders.join(&quot;, &quot;) : '';
        var group = (this.groups.length &gt; 0) ? ' GROUP BY ' + this.groups.join(&quot;, &quot;) : '';
        var query = 'SELECT ' + this.fields.join(&quot;, \n\t&quot;) + &quot;\n FROM \n\t&quot; + CRUD.EntityManager.entities[this.entity].table + &quot;\n &quot; + this.joins.join(&quot;\n &quot;) + where + ' ' + group + ' ' + order + ' ' + this.limit;
        return ({
            query: query,
            parameters: this.parameters
        });
    },

    buildCountQuery: function() {
        var where = (this.wheres.length &gt; 0) ? ' WHERE ' + this.wheres.join(&quot; \n AND \n\t&quot;) : '';
        var group = (this.groups.length &gt; 0) ? ' GROUP BY ' + this.groups.join(&quot;, &quot;) : '';
        var query = &quot;SELECT count(&quot; + CRUD.EntityManager.entities[this.entity].primary + &quot;) FROM \n\t&quot; + CRUD.EntityManager.entities[this.entity].table + &quot;\n &quot; + this.joins.join(&quot;\n &quot;) + where + ' ' + group;
        return ({
            query: query,
            parameters: this.parameters
        });
    }
};</code></pre>
          <div class="footer site-footer">
            <div class="span site-footer-owner"><a href="https://github.com/mr-doc/mr-doc-theme-cayman">Cayman</a> is maintained by <a href="https://github.com/iwatakeshi">iwatakeshi</a>.</div>
            <div class="span site-footer-credits">This page was generated by <a href="https://github.com/mr-doc/mr-doc">Mr. Doc</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</div>
          </div>
        </div>
      </div>
    </section>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/affix.js"></script>
    <script src="js/dropdown.js"></script>
    <script src="js/scrollspy.js"></script>
    <script src="js/prism.js"></script>
    <script src="js/prism-bash.js"></script>
    <script>
      $(document).ready(function(){
        $('body').scrollspy({
          target: ".bs-docs-sidebar",
          offset: 40
        });
        $('#sidebar').affix({
          offset:{
            bottom:60,
            top: 60
          }
        }) 
      });
    </script>
  </body>
</html>